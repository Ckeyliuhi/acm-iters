数学
素数筛法
---
const int N = 50005;
bitset <N> prime;
void init () {
    for (int i = 2; i < N; ++i)
        for (int j = i * 2; j < N; j += i)
            prime[j] = 1;
}
--- 
// 素因数分解 O(√N)
---
vector <pair<int, int>> factor (int x) {
    vector <pair<int, int>> ans;
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0) {
            ans.push_back({i, 1});
            if ((x /= i) % i == 0) ans.back().second++;
        }
    }
    if (x > 1) ans.push_back({x, 1});
    return ans;
}
---
---
素数check 
---
出1素数 出0不是
bool check (int x) {
    if (x <= 1) return false;
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0) return false;
    }
    return true;
} 
---
最小质因子筛 euler 
---
const int N = 1e5 + 5; 
vector<int> prime;
int minp[N]; 
void euler_seive() {
    for (int i = 2; i < N; ++i) {
        if (!minp[i]) minp[i] = i, prime.emplace_back(i);
        for (auto& p : prime) {
            if (i * p >= N) break;
            minp[i * p] = p;
            if (i % p == 0) break;
        }
    }
}
---
因子筛选PLUS版本
---
const int N = 1e5 + 5; 
vector<int> prime;
int fac[N], cnt[N];//cnt为最小质因子数 fac为因子数

void euler_seive() {
    fac[1] = 1;//特判 1
    for (int i = 2; i < N; ++i) {
        if (!fac[i]) fac[i] = 2, cnt[i] = 1, prime.emplace_back(i);
        for (auto& p : prime) {
            if (p * i >= N) break;
            if (i % p == 0) {
                fac[i * p] = fac[i] / (cnt[i] + 1) * (cnt[i] + 2);
                cnt[i * p] = cnt[i] + 1;
                break;
            }
            fac[i * p] = fac[i] * fac[p];
            cnt[i * p] = 1;
        }
    }
}
---
普通筛选
---
const int N = 1e5 + 5; 
vector<int> prime;
bitset <N> isp; 
void euler_seive() {
    for (int i = 2; i < N; ++i) {
        if (!isp[i]) prime.emplace_back(i);
        for (auto& p : prime) {
            if (i * p >= N) break;
            isp[i * p] = true;
            if (i % p == 0) break;
        }
    }
}
/*
使用:
*euler_seive() <预处理> 
-if(!isp[idx]) <对 idx 进行素性判断，质数为false>
-prime[idx]
*/
---
快速幂 qpow
---
typedef long long ll; 
const ll mod = 1e9 + 7;  
ll qpow(ll a, ll b) {
    ll res = 1;
    for ( ; b > 0; b >>= 1, a = a * a % mod) {
        if (b & 1) res = res * a % mod;
    }
    return res;
}
---
组合数Comb
---
typedef long long ll;
const int N = 1e5 + 5;
const ll mod = 1e9 + 7; 
struct Comb {
    ll f[N], g[N]; 
    ll qpow(ll a, ll b) {
        ll res = 1;
        for (; b > 0; b >>= 1, a = a * a % mod) {
            if (b & 1) res = res * a % mod;
        }
        return res;
    } 
    void init() {
        f[0] = 1; g[0] = 1;
        for (int i = 1; i < N; i++) {
            f[i] = f[i - 1] * i % mod;
            g[i] = g[i - 1] * qpow(i, mod - 2) % mod;
        }
    } 
    ll C(int n, int m) {
        if (m > n) return 0;
        return f[n] * g[n - m] % mod * g[m] % mod;
    } 
    ll A(int n, int m) {
        if (m > n) return 0;
        return f[n] * g[n - m] % mod;
    }
};
// main -> Comb comb, comb.init(), comb.C() or comb.A直接使用
--- 
图论
链式前向星
---
const int N = 1e5 + 5, M = 2e5 + 5;
struct Edges {
    int to, w, next;
} edges[M];
int head[N], cnt = 0, n, m;
void init() {
    memset (head, -1, sizeof(head));
    cnt = 0;
}

void addEdges(int from, int to, int w) {
    edges[cnt] = {to, w, head[from]};
    head[from] = cnt++;
}
/*
for (int to = head[from]; ~to; to = edges[to].next) {
    
}
*/
---
Kruskal最小生成树
---
const int N = 1e5 + 5;
int f[N];

int find(int x) { 
    return f[x] == x ? x : f[x] = find(f[x]);
}  

void init() {
    for (int i = 1; i < N; i++) {
        f[i] = i;
    }
}

struct Edge {
    int from, to, w;
    bool operator<(const Edge& other) const {
        return w < other.w; 
    }
};

int n, m, p; 
vector<Edge> edges;  
int ans = 0;

bool Kruskal() {
    sort(edges.begin(), edges.end());
    init();
    int cnt = 0;
    for (const Edge& edge : edges) {
        int from = edge.from, to = edge.to, w = edge.w; 
        from = find(from); 
        to = find(to);
        if (from != to) {
            cnt++;
            ans += w;
            f[to] = from;
            if (cnt == n - 1) break;
        }
    }
    return cnt >= n - 1;
}
---
Kruskal2 find 最小的情况使得s -> t
---
const int N = 1e5 + 5;
int f[N], n, m;
int s, t;
struct Edge {
    int from, to, w;
    bool operator < (const Edge &other) const {
        return w < other.w;
    }
} ;
vector <Edge> adj; 
int find (int x) {
    if (f[x] != x) {
        return f[x] = find(f[x]);
    }
    return x;
}

void init() {
    for (int i = 1; i <= n; i++) {
        f[i] = i;
    } 
}
    
bool Kruskal(int mid) { // find 最小的情况使得s -> t
    init();
    sort(adj.begin(), adj.end());
    for (auto [from, to, w] : adj) {
        from = find(from);
        to = find(to);
        if (w <= mid) {
            if (from != to) {
                f[to] = from;
            }
        }
    }
    return find(s) == find(t);
}
---
单源最短路dijkstra
---
const int N = 1e5 + 5;
int n, m, dist[N];
bitset <N> vis;
vector <pair<int, int>> edges[N];
void addedges(int from, int to, int w) {
    edges[from].push_back({w, to});
    // edges[to].push_back({w, from});
}

void dijkstra(int s) {
    for (int i = 1; i <= n; i++) dist[i] = INT_MAX;
    priority_queue <pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    dist[s] = 0; pq.push({0, s});
    while (pq.size()) {
        pair<int, int> now = pq.top(); pq.pop();
        int from = now.second;
        if (vis[from]) continue;
        vis[from] = 1;
        for (pair<int, int> cur : edges[from]) {
            int w = cur.first, to = cur.second;
            if (dist[to] > dist[from] + w) {
                dist[to] = dist[from] + w;
                pq.push({dist[to], to});
            }
        }
    }
}
---
dijkstra正反向图
---
typedef long long ll;
const int N = 1e6 + 5, M = 1e6 + 5;
ll dist[N];
bool vis[N];
int n, m, head[N], cnt = 0;
struct Edge { // define an edge 
    int to, w, next;
} edge[M];

void init_work() {
    memset (head, -1, sizeof(head)); 
    cnt = 0;
}

void addedge (int from, int to, int w) {
    edge[++cnt] = {to, w, head[from]};
    head[from] = cnt;
}

void addedge_reverse (int to, int from, int w) {
    edge[++cnt] = {to, w, head[from]};
    head[from] = cnt;
} 

void dijkstra() {
    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;
    memset(dist, 0x3f, sizeof(dist));
    memset(vis, 0, sizeof(vis));
    dist[1] = 0;
    pq.push({0, 1});
    while (!pq.empty()) {
        auto [w, from] = pq.top();
        pq.pop();
        if (vis[from]) continue;
        vis[from] = 1;
        for (int i = head[from]; ~i; i = edge[i].next) {
            int to = edge[i].to;
            if (dist[to] > dist[from] + edge[i].w) {
                dist[to] = dist[from] + edge[i].w;
                pq.push({dist[to], to});
            }
        }
    }
} 

/*
链式前向行版本的dijkstra 
正向图 addedge
反向图 addedge_reverse
*/
全源最短路Floyd
---
const int N = 1e2 + 5;
const int inf = 1e9;
int n, m, dp[N][N]; 
void init () {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (i != j) dp[i][j] = inf;
        }
    } 
} 
void Floyd () {
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = min(dp[i][k] + dp[k][j], dp[i][j]);
            }
        }
    }
} 
--- 
拓扑排序priority_queue or queue
---
const int N = 1e5 + 5;
int n, indep[N], m; // 入度
vector <int> adj[N];
vector <int> ans;  
bool Topsort() {
    priority_queue <int, vector<int>, greater<int>> pq; //小根堆
    // queue <int> q;
    for (int i = 1; i <= n; i++) {
        if (!indep[i]) {
            pq.push(i);
            // q.push(i);
        }
    }
    while (!pq.empty()) {
        int from = pq.top(); pq.pop();
        //int from = q.front(); q.pop();
        ans.push_back(from);
        for (int to : adj[from]) {
            if (--indep[to] == 0) {
                pq.push(to);
                // q.push(to);
            } 
        }
    } 
    return ans.size() == n;
}
---
BFS(bfs) 
---
const int N = 1e3 + 4;
int dirs[5] = {-1, 0, 1, 0, -1};
bool vis[N][N];
int n, m;
char a[N][N];
// int a[N][N];s
bool check (int x, int y) {
    return x >= 1 && x <= n && y >= 1 && y <= m && !vis[x][y];
} 
void bfs (int sx, int sy) {
    queue <array<int, 3>> q;
    q.push({sx, sy, 0});
    vis[sx][sy] = 1;
    a[sx][sy] = '0';
    while (!q.empty()) {
        auto [x, y, cnt] = q.front();
        q.pop();
        // if (x == n && y == m) {
            // cout << cnt << '\n';
            // return ;
        // }
        for (int i = 0; i < 4; i++) {
            int dx = dirs[i] + x;
            int dy = dirs[i + 1] + y;
            if (check (dx, dy)) { // 自己额外填的
                vis[dx][dy] = 1; 
                q.push({dx, dy, cnt + 1});
            }
        }
    }
}
--- 
---
LCA 最近公共祖先
const int N = 5e5 + 5;
int n, m, s; //树的结点个数、询问的个数和树根结点的序号
int dep[N], f[N][20];
vector <int> adj[N]; // (n + m) log(m)
 
void dfs(int from, int fa) { // from 是儿子 fa 是父亲
    dep[from] = dep[fa] + 1;
    f[from][0] = fa; //它的上一层是它的父亲
    for (int i = 1; i <= 19; i++) {
        f[from][i] = f[f[from][i - 1]][i - 1];
    }
    for (int to : adj[from]) {
        if (to != fa) dfs(to, from);
    }
}
 
int lca(int from, int to) { // from 和 to 跳到同一层
    if (dep[from] < dep[to]) swap(from, to); // 只让from 跳
    for (int i = 19; i >= 0; i--) {
        if (dep[f[from][i]] >= dep[to]) {
            from = f[from][i];
        }
    }
    if (from == to) return to; //恰好to是它的祖先
    for (int i = 19; i >= 0; i--) {
        if (f[from][i] != f[to][i]) { //如果不相同则让它们走上去
            from = f[from][i]; to = f[to][i];
        }
    }
    return f[from][0];
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n >> m >> s;
    for (int i = 1; i < n; i++) {
        int from, to; cin >> from >> to;
        adj[from].push_back(to);
        adj[to].push_back(from);
    }
    dfs(s, 0);
    while (m--) {
        int from, to; cin >> from >> to;
        cout << lca(from, to) << '\n';
    }
    return 0;
}
---
Trajan 最近公共祖先
---
using namespace std;
const int N = 5e5 + 5;
int n, m, s, f[N], ans[N];
bool vis[N];
vector <int> adj[N];
vector <pair<int, int>> query[N];
 
int find(int x) {
    return f[x] == x ? x : f[x] = find(f[x]);
}
 
void Trajan(int from) {
    vis[from] = 1;
    for (int to : adj[from]) {
        if (!vis[to]) {
            Trajan(to);
            f[to] = from;
        }
    }
    for (auto [to, id] : query[from]) {
        if (vis[to]) ans[id] = find(to);
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n >> m >> s;
    for (int i = 1; i < n; i++) {
        int from, to; cin >> from >> to;
        adj[from].push_back(to);
        adj[to].push_back(from);
    }
    for (int i = 1; i <= m; i++) {
        int from, to; cin >> from >> to;
        query[from].push_back({to, i});
        query[to].push_back({from, i});
    }
    for (int i = 1; i < N; i++) f[i] = i;
    Trajan(s);
    for (int i = 1; i <= m; i++) cout << ans[i] << '\n';
    return 0;
}
---
匈牙利 KM算法
const int M = 1e3 + 5;
struct KM  { 
    int pl[M], pr[M], visl[M], visr[M], n, m, i, j, k, it;
    vector<int> vl[M], vr[M]; 
    void init(int n0, int m0) {
        n = n0;
        m = m0;
        it = 0;
        for (i = 1; i <= n; i++) {
            visl[i] = 0; pl[i] = -1; vl[i].clear();
        }
        for (i = 1; i <= m; i++) {
            visr[i] = 0; pr[i] = -1; vr[i].clear();
        }
    } 
    void add(int from, int to) { // 添加一条边
        vl[from].push_back(to);
        vr[to].push_back(from);
    }  
    bool dfsl(int from) { // 从左边节点进行深度优先搜索
        if (visl[from] == it) return 0;
        visl[from] = it;
        for (auto i : vl[from]) {
            if (pr[i] == -1) {
                pl[from] = i;
                pr[i] = from;
                return 1;
            }
        }
        for (auto i : vl[from]) {
            if (visr[pr[i]] != it && dfsl(pr[i])) {
                pl[from] = i;
                pr[i] = from;
                return 1;
            }
        }
        return 0;
    } 
    bool dfsr(int from) { // 从右边节点进行深度优先搜索
        if (visr[from] == it) return 0;
        visr[from] = it;
        for (auto i : vr[from]) {
            if (pl[i] == -1) {
                pr[from] = i;
                pl[i] = from;
                return 1;
            }
        }
        for (auto i : vr[from]) {
            if (visl[pl[i]] != it && dfsr(pl[i])) {
                pr[from] = i;
                pl[i] = from;
                return 1;
            }
        }
        return 0;
    } 
    bool getl(int from) { // 尝试匹配左边节点
        it++;
        return dfsl(from);
    } 
    bool getr(int from) { // 尝试匹配右边节点
        it++;
        return dfsr(from);
    }
} km ;
数据结构
---
单调栈
--- 
---
字典树
---
const int N = 1e5 + 5;
int trie[N][63], cnt[N]; 
// bool ext[N];
bitset <N> ext[N];
int idx_;

void init() { 
    idx_ = 0;
    for (int i = 0; i < N; ++i) {
        cnt[i] = 0;
        ext[i] = false;
        for (int j = 0; j < 63; ++j) {
            trie[i][j] = 0;
        }
    }
}

int check(char c) { 
    if (c >= 'a' && c <= 'z') return c - 'a';     // [0 ~ 25]
    if (c >= 'A' && c <= 'Z') return c - 'A' + 26; // [26 ~ 51]
    if (c >= '0' && c <= '9') return c - '0' + 52; // [52 ~ 60]
    return -1;
}

void insert(const string& s) {
    int p = 0;
    for (char c : s) {
        int idx = check(c);
        if (idx == -1) continue; 
        if (!trie[p][idx]) trie[p][idx] = ++idx_;
        p = trie[p][idx]; 
        cnt[p]++; 
    }
    ext[p] = true;
}

int query(const string& s) {
    int p = 0;
    for (char c : s) {
        int idx = check(c);
        if (idx == -1 || !trie[p][idx]) return 0;
        p = trie[p][idx]; 
    }
    return cnt[p];
}

bool query_ext(const string& s) {
    int p = 0;
    for (char c : s) {
        int idx = check(c);
        if (idx == -1 || !trie[p][idx]) return false;
        p = trie[p][idx]; 
    }
    return ext[p];
} 
/*
insert(s)  // 插入字符串函数 
query(s) // 查询字符串出现次数的函数 
query_ext // 查询字符串是否为完整单词的函数
*/
---
并查集 DSU
---
const int N = 1e5 + 5; 
int f[N]; int sz[N];
// unordered_map <int, int> f;// 离散化
void init (int n) {
    for (int i = 1; i <= n; i++) {
        f[i] = i, sz[i] = 1;
    }
}
int find(int x) { 
    return f[x] == x ? x : f[x] = find(f[x]);
} 

void merge (int x, int y) {  
    x = find(x); y = find(y);
    if (x == y) return ;
    if (sz[x] < sz[y]) swap(x, y);
    sz[x] += sz[y];
    f[y] = x;
}

bool isSame (int x, int y) {  
    return find(x) == find(y);
}

// void init_ () {
//     f.clear();
// }

// void merge_ (int x, int y) {
//     x = find(x); y = find(y);
//     f[y] = x;
// } 
/*
find(int x) -> 查询x节点的父亲
getSz(int x) -> 查询x节点所在并查集的大小
isSame(int x, int y) -> 查询x节点和y节点是否是在同一并查集内
merge(int x, int y) -> 合并x节点和y节点的并查集
离散化操作init_ + merge_其余不变
*/
---
线段树SegTree
---  
普通sum求和
typedef long long ll; 
const int N = 1e5 + 5;
ll a[N];
struct SegTree {
    ll sum;
    ll lazy;  
} seg[N << 2];

void push_down(int rt, int l, int r) {
    if (seg[rt].lazy != 0) {
        int mid = (l + r) >> 1; 
        seg[rt << 1].sum += (mid - l + 1) * seg[rt].lazy;
        seg[rt << 1 | 1].sum += (r - mid) * seg[rt].lazy; 
        seg[rt << 1].lazy += seg[rt].lazy;
        seg[rt << 1 | 1].lazy += seg[rt].lazy; 
        seg[rt].lazy = 0;
    }
}

void build(int rt, int l, int r) {
    if (l == r) {
        seg[rt].sum = a[l];
        seg[rt].lazy = 0;
        return;
    }
    int mid = (l + r) >> 1;
    build(rt << 1, l, mid);
    build(rt << 1 | 1, mid + 1, r);
    seg[rt].sum = seg[rt << 1].sum + seg[rt << 1 | 1].sum;
    seg[rt].lazy = 0;
}

void update(int rt, int l, int r, int L, int R, ll val) {
    if (L <= l && r <= R) {
        seg[rt].sum += (r - l + 1) * val;
        seg[rt].lazy += val;
        return;
    }
    push_down(rt, l, r);
    int mid = (l + r) >> 1;
    if (L <= mid) update(rt << 1, l, mid, L, R, val);
    if (R > mid) update(rt << 1 | 1, mid + 1, r, L, R, val);
    seg[rt].sum = seg[rt << 1].sum + seg[rt << 1 | 1].sum;
}

ll query(int rt, int l, int r, int L, int R) {
    if (L <= l && r <= R) {
        return seg[rt].sum;
    }
    push_down(rt, l, r);
    int mid = (l + r) >> 1;
    ll res = 0;
    if (L <= mid) res += query(rt << 1, l, mid, L, R);
    if (R > mid) res += query(rt << 1 | 1, mid + 1, r, L, R);
    return res;
}
---
树状数组Bit(BIT)
--- 
未封装函数
typedef long long ll;
const int N = 1e5 + 5;
ll tree[N], a[N]; 
int lowbit (int x) { return x & -x; } // 最低位1的位置
void add (int x, int val) { // 单点更新 x 是索引  val 是增量
    for ( ; x <= n + 1; x += lowbit(x)) {
        tree[x] += val;
    }
}

ll query (int x) { // 查询[1 - x]的和
    ll res = 0;
    for ( ; x > 0; x -= lowbit(x)) {
        res += tree[x];
    }
    return res;
}
---
字符串
哈希 Hash (前后缀)
---
typedef unsigned long long ull;
const int P = 131, N = 1e6 + 5;
string s;
ull h[N], p[N];
// ull hs[N], ps[N];

void init() {
    int len = s.size();
    p[0] = 1; h[0] = 0; 
    // ps[len] = 1; hs[len] = 0; 
    for (int i = 0; i < len; i++) {
        h[i + 1] = h[i] * P + s[i];
        p[i + 1] = p[i] * P;
    } 
    // for (int i = len - 1; i >= 0; i--) {
        // hs[i] = hs[i + 1] * P + s[i];
        // ps[i] = ps[i + 1] * P;
    // }
}  
// ull get_suf(int l, int r) {
//     return hs[l] - hs[r + 1] * ps[l - r];
// }
 
// bool check_suf(int l1, int r1, int l2, int r2) {
//     return get_suf(l1, r1) == get_suf(l2, r2);
// }

ull get (int l, int r) {
    return h[r] - h[l - 1] * p[r - l + 1];
}

bool check (int l1, int r1, int l2, int r2) {
    return get(l1, r1) == get(l2, r2);
}
---
最小表达式
---
int getMin() {
    v.insert(v.end(), v.begin(), v.end()); // 2 * n 的空间
    int i = 0, j = 0, k = 0;
    for ( ; i < n && j < n; ) {
        for (k = 0; k < n && v[i + k] == v[j + k]; k++);
        v[i + k] > v[j + k] ? i = i + k + 1 : j = j + k + 1;
        if (i == j) j ++;
    }
    return min(i, j);
}
---
Manache 马拉车最长回文串
---
const int N = 1e7 + 1e6 + 5;
int n, p[N << 1], maxi;
char a[N], s[N << 1]; 

void init() { // #a#a#a# 形式
    int i = 0, j = 0; 
    s[j++] = '#';
    for (i = 0; i < n; i++) {
        s[j++] = a[i]; s[j++] = '#'; 
    }
    n = j;
}

// maxi -> (长度 + 中心 - 1) >> 1

int manacher () {
    int maxlen = 0; // 真实长度
    for (int i = 0, c = 0, r = 0, len; i < n; i++) {
        len = r > i ? min(p[c * 2 - i], r - i) : 1; // 被包住
        while (i + len < n && i - len >= 0 && s[i + len] == s[i - len]) len++;
        if (i + len > r) r = i + len, c = i; // 更新
        p[i] = len; 
        if (maxlen < len) { 
            maxi = i;
            maxlen = len;
        } 
    }
    return maxlen - 1; //真实长度(len - 1)
}
---
计算几何
---
typedef long long ll;
#define pi (acos(-1.0))
#define eps (1e-8)
#define inf (1 << 30)
#define INF (1ll << 62)

inline double sqr(const double &x) { // x * x
    return x * x;
}
 
inline int sgn(const double &x) { // [-1 负 0 零 1 正]
    return x < -eps ? -1 : x > eps;
} 

struct point { // 二维
    double x, y;
    point(const double &x = 0, const double &y = 0): x(x), y(y) {}  
    friend point operator + (const point &a, const point &b) { // +
        return point(a.x + b.x, a.y + b.y);
    } 
    friend point operator - (const point &a, const point &b) { // -
        return point(a.x - b.x, a.y - b.y);
    } 
    friend point operator * (const point &a, const double &b) { // *
        return point(a.x * b, a.y * b);
    } 
    friend point operator * (const double &a, const point &b) { // *
        return point(a * b.x, a * b.y);
    } 
    friend point operator / (const point &a, const double &b) { // divides
        return point(a.x / b, a.y / b);
    } 
    friend bool operator == (const point &a, const point &b) { // 点==点
        return !sgn(a.x - b.x) && !sgn(a.y - b.y);
    } 
    friend bool operator < (const point &a, const point &b) { // 点<点
        return sgn(a.x - b.x) < 0 || (sgn(a.x - b.x) == 0 && sgn(a.y - b.y) < 0);
    } 
    double norm() { // 点到原点的距离
        return sqrt(sqr(x) + sqr(y));
    } 
    friend double det(const point &a, const point &b) { // 两个向量叉积
        return a.x * b.y - a.y * b.x;
    } 
    friend double dot(const point &a, const point &b) { // 两个向量点积
        return a.x * b.x + a.y * b.y;
    } 
    friend double dist(const point &a, const point &b) { // 两点距离
        return (a - b).norm();
    } 
    double arg() { // 点到x轴的夹角
        return atan2(y, x);
    } 
    point rotate(const double &angle) { // 逆时针
        return rotate(cos(angle), sin(angle));
    } 
    point rotate(const point &p, const double &angle) { // 以某点为中心旋转指定角度
        return (*this - p).rotate(angle) + p;
    } 
    point rotate(const double &cosa, const double &sina) { // 根据给定的cos和sin值旋转点
        return point(x * cosa - y * sina, x * sina + y * cosa);
    } 
    void in() { // 输入点的坐标
        cin >> x >> y;
    } 
    void out() { // 输出点的坐标
        cout << fixed << setprecision(2) << x << " " << y << endl;
    }
};
 
struct line { // 定义直线结构体
    point s, t;
    line(const point &s = point(), const point &t = point()): s(s), t(t) {} 
    point vec() const { // 获取直线的向量
        return t - s;
    } 
    double norm() const { // 计算直线的长度
        return vec().norm();
    } 
    bool ispointonline(const point &p) const { // 判断点是否在直线上
        return sgn(det(p - s, t - s)) == 0;
    } 
    bool ispointonseg(const point &p) const { // 判断点是否在线段上
        return ispointonline(p) && sgn(dot(p - s, p - t)) <= 0;
    } 
    bool ispointonsegex(const point &p) { // 判断点是否在线段上，不包含端点
        return ispointonline(p) && sgn(dot(p - s, p - t)) < 0;
    } 
    point pointprojline(const point &p) { // 计算点到直线的垂足
        return s + vec() * ((dot(p - s, vec()) / norm()) / norm());
    } 
    double pointdistline(const point &p) { // 计算点到直线的距离
        return fabs(det(p - s, vec()) / norm());
    } 
    double pointdistseg(const point &p) { // 计算点到线段的距离
        if (sgn(dot(p - s, t - s)) < 0) return (p - s).norm();
        if (sgn(dot(p - t, s - t)) < 0) return (p - t).norm();
        return pointdistline(p);
    } 
    friend bool parallel(const line &l1, const line &l2) { // 判断两条直线是否平行
        return !sgn(det(l1.vec(), l2.vec()));
    } 
    friend bool sameside(const line &l, const point &a, const point &b) { // 判断两个点是否在直线的同一侧
        return sgn(det(b - l.s, l.vec())) * sgn(det(a - l.s, l.vec())) > 0;
    } 
    friend point linexline(const line &l1, const line &l2) { // 计算两条直线的交点
        double s1 = det(l1.s - l2.s, l2.vec());
        double s2 = det(l1.t - l2.s, l2.vec());
        return (l1.t * s1 - l1.s * s2) / (s1 - s2);
    } 
    friend bool issegxseg(const line &l1, const line &l2) { // 判断两条线段是否相交
        if(!sgn(det(l2.s - l1.s, l1.vec())) && !sgn(det(l2.t - l1.s, l1.vec()))) {
            return l1.ispointonseg(l2.s) ||
                   l1.ispointonseg(l2.t) ||
                   l2.ispointonseg(l1.s) ||
                   l2.ispointonseg(l1.t);
        }
        return !sameside(l1, l2.s, l2.t) && !sameside(l2, l1.s, l1.t);
    } 
    friend line move(const line &l, const double &d) { // 直线沿法线方向移动d距离
        point t = l.vec();
        t = t / t.norm();
        t = t.rotate(pi / 2);
        return line(l.s + t * d, l.t + t * d);
    } 
    void in() { // 输入 
        s.in();
        t.in();
    } 
    void out() { //输出直线的两个端点
        s.out();
        t.out();
    }
};
---
两点距离
double dis(int i, int j){ 
    double x1 = x[i] - x[j], y1 = y[i] - y[j];
    return __builtin_sqrtl(x1 * x1 + y1 * y1);
}
---
杂项
闰年LeapYear
--- 
bool isLeapYear(int year) {
    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
}
---