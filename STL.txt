#include <algorithm>
#include <numeric>
#include <vector>
#include <cstring>  // 用于strtok
#include <iostream>

// 1. 使用欧几里得算法计算最大公约数
int gcd(int a, int b) {
    return std::__gcd(a, b);
}

// 2. 对数组范围 [0, n) 建堆
void buildHeap(int* a, int n) {
    std::make_heap(a, a + n);
}

// 3. 将第 n-1 个元素插入到堆 [0, n-1) 中
void pushToHeap(int* a, int n) {
    std::push_heap(a, a + n);
}

// 4. 将堆 [0, n) 中的最大值取出，并放置在数组的最后位置
void popFromHeap(int* a, int n) {
    std::pop_heap(a, a + n);
}

// 5. 对堆 [0, n) 进行排序
void sortHeap(int* a, int n) {
    std::sort_heap(a, a + n);
}

// 6. 翻转容器内的元素顺序
void reverseContainer(std::vector<int>& v) {
    std::reverse(v.begin(), v.end());
}

// 7. 统计容器中等于 key 的元素个数
int countElements(const std::vector<int>& v, int key) {
    return std::count(v.begin(), v.end(), key);
}

// 8. 统计容器中符合 pred 条件的元素个数
int countIfElements(const std::vector<int>& v, bool(*pred)(int)) {
    return std::count_if(v.begin(), v.end(), pred);
}

// 9. 删除容器中值为 key 的元素，并返回新的末尾迭代器
void removeKey(std::vector<int>& v, int key) {
    v.erase(std::remove(v.begin(), v.end(), key), v.end());
}

// 10. 删除容器中符合 pred 条件的元素，并返回新的末尾迭代器
void removeIfCondition(std::vector<int>& v, bool(*pred)(int)) {
    v.erase(std::remove_if(v.begin(), v.end(), pred), v.end());
}

// 11. 排重容器中的元素，并返回新的末尾迭代器
void uniqueElements(std::vector<int>& v) {
    v.erase(std::unique(v.begin(), v.end()), v.end());
}

// 12. 查找容器中值为 key 的元素，返回迭代器；如果找不到，则返回 end()
auto findKey(const std::vector<int>& v, int key) {
    return std::find(v.begin(), v.end(), key);
}

// 13. 生成下一个全排列，有则返回 true，无则返回 false
bool nextPermutation(std::vector<int>& v) {
    return std::next_permutation(v.begin(), v.end());
}

// 14. 生成上一个全排列，有则返回 true，无则返回 false
bool prevPermutation(std::vector<int>& v) {
    return std::prev_permutation(v.begin(), v.end());
}

// 15. 查找可以插入 value 而不会破坏容器顺序的第一个位置
auto lowerBound(const std::vector<int>& v, int key) {
    return std::lower_bound(v.begin(), v.end(), key);
}

// 16. 查找可以插入 value 而不会破坏容器顺序的最后一个位置
auto upperBound(const std::vector<int>& v, int key) {
    return std::upper_bound(v.begin(), v.end(), key);
}

// 17. 将容器内的元素按 pred 条件分开，满足条件的元素放在前面，返回分割点的迭代器
auto partitionContainer(std::vector<int>& v, bool(*pred)(int)) {
    return std::partition(v.begin(), v.end(), pred);
}

// 18. 求两个容器的内积，并返回结果加上初始值 sum
int innerProduct(const std::vector<int>& v1, const std::vector<int>& v2, int sum) {
    return std::inner_product(v1.begin(), v1.end(), v2.begin(), sum);
}

// 19. 对容器内的元素求和，并返回结果加上初始值 sum
int accumulateElements(const std::vector<int>& v, int sum) {
    return std::accumulate(v.begin(), v.end(), sum);
}

// 20. 找到容器内的最大/最小值
auto maxElement(const std::vector<int>& v) {
    return std::max_element(v.begin(), v.end());
}

auto minElement(const std::vector<int>& v) {
    return std::min_element(v.begin(), v.end());
}

// 21. 重新排列容器内的元素，使得第 n 小的元素位于它应该在的位置上
void nthElement(std::vector<int>& v, int n) {
    std::nth_element(v.begin(), v.begin() + n, v.end());
}

// 22. 将容器内的所有元素赋值为 key
void fillContainer(std::vector<int>& v, int key) {
    std::fill(v.begin(), v.end(), key);
}

// 23. 复制容器 v1 的元素到 v2
void copyContainer(const std::vector<int>& v1, std::vector<int>& v2) {
    std::copy(v1.begin(), v1.end(), v2.begin());
}

// 24. 按字典序比较两个容器
bool lexicographicalCompare(const std::vector<int>& v1, const std::vector<int>& v2) {
    return std::lexicographical_compare(v1.begin(), v1.end(), v2.begin(), v2.end());
}

// 25. 合并两个有序容器 v1 和 v2 到 v 中
void mergeContainers(const std::vector<int>& v1, const std::vector<int>& v2, std::vector<int>& v) {
    std::merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v.begin());
}

// 26. 就地合并有序容器 [first, middle) 和 [middle, last)
void inplaceMerge(std::vector<int>& v, auto first, auto middle, auto last) {
    std::inplace_merge(first, middle, last);
}

// 27. 交换区间 [first, middle) 和 [middle, last)
void rotateElements(std::vector<int>& v, auto first, auto middle, auto last) {
    std::rotate(first, middle, last);
}

// 28. 随机打乱容器内的元素顺序
void randomShuffle(std::vector<int>& v) {
    std::random_shuffle(v.begin(), v.end());
}

// 29. 计算前缀和，结果存放在 dst 中
void partialSum(const int* src, int* dst, int n) {
    std::partial_sum(src, src + n, dst);
}

// 30. 计算差分，结果存放在 dst 中
void adjacentDifference(const int* src, int* dst, int n) {
    std::adjacent_difference(src, src + n, dst);
}

// 31. 将字符串按 base 进制转换为 long，并通过 ed 得到未被识别的第一个字符的指针
long stringToLong(const char* s, char** ed, int base) {
    return std::strtol(s, ed, base);
}

// 32. 使用字符串 str2 中的字符分隔 str1，第一次调用传入 str1，后续传入 NULL，直到返回 NULL 表示分隔完毕
void tokenizeString(char* str1, const char* str2) {
    char* result = std::strtok(str1, str2);
    while (result != NULL) {
        std::cout << "result is \"" << result << "\"\n";
        result = std::strtok(NULL, str2);
    }
}
